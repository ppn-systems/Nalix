// Copyright (c) 2025 PPN Corporation. All rights reserved.

using Nalix.Common.Logging.Abstractions;
using Nalix.Common.Packets.Abstractions;
using Nalix.Common.Protocols;            // ProtocolType
using Nalix.Framework.Cryptography.Asymmetric;
using Nalix.Framework.Cryptography.Hashing;
using Nalix.Framework.Injection;
using Nalix.Shared.Messaging.Controls;

namespace Nalix.SDK.Remote.Extensions;

/// <summary>
/// Provides extension methods to perform a cryptographic handshake on <see cref="ReliableClient"/>.
/// </summary>
/// <remarks>
/// This client-side flow mirrors the server:
/// generate an X25519 keypair, send a <see cref="Handshake"/> containing the client public key,
/// receive the server's public key, derive a shared secret, and install a 32-byte key using SHA-256.
/// </remarks>
/// <seealso cref="ReliableClient"/>
/// <seealso cref="Handshake"/>
public static class HandshakeExtensions
{
    /// <summary>
    /// Initiates the handshake by generating an X25519 keypair and sending a <see cref="Handshake"/>
    /// that carries the client's 32-byte public key to the server.
    /// </summary>
    /// <param name="client">The connected <see cref="ReliableClient"/>.</param>
    /// <param name="opCode">The operation code for the handshake packet.</param>
    /// <param name="ct">A token used to observe cancellation.</param>
    /// <returns>
    /// The generated <see cref="X25519.X25519KeyPair"/> that must be supplied to
    /// <see cref="FinishHandshake(ReliableClient, X25519.X25519KeyPair, IPacket)"/>.
    /// </returns>
    /// <exception cref="System.ArgumentNullException">Thrown when <paramref name="client"/> is <c>null</c>.</exception>
    /// <exception cref="System.InvalidOperationException">Thrown when the client is not connected or a key is already installed.</exception>
    /// <exception cref="System.OperationCanceledException">Thrown when <paramref name="ct"/> is canceled.</exception>
    /// <remarks>
    /// If a 32-byte encryption key is already present on the client, this method throws to prevent
    /// a repeated handshake attempt on an upgraded connection (aligns with server behavior).
    /// </remarks>
    /// <example>
    /// <code>
    /// var keyPair = await client.InitiateHandshakeAsync(ct);
    /// var response = await client.ReceiveAsync(ct); // expecting a Handshake packet from server
    /// bool ok = client.FinishHandshake(keyPair, response);
    /// </code>
    /// </example>
    public static async System.Threading.Tasks.Task<X25519.X25519KeyPair> InitiateHandshakeAsync(
        this ReliableClient client, System.UInt16 opCode,
        System.Threading.CancellationToken ct = default)
    {
        System.ArgumentNullException.ThrowIfNull(client);

        if (!client.IsConnected)
        {
            throw new System.InvalidOperationException("Client not connected.");
        }

        // Optional guard: avoid re-handshake on an upgraded connection.
        if (client.Options.EncryptionKey is { Length: 32 })
        {
            throw new System.InvalidOperationException("Handshake already completed: encryption key is installed.");
        }

        X25519.X25519KeyPair keyPair = X25519.GenerateKeyPair();

        await client.SendAsync(new Handshake(opCode, keyPair.PublicKey, ProtocolType.TCP), ct)
                    .ConfigureAwait(false);

        InstanceManager.Instance.GetExistingInstance<ILogger>()?
                                .Debug("Handshake request sent (client public key).");
        return keyPair;
    }

    /// <summary>
    /// Completes the handshake using the server's response <see cref="Handshake"/> packet.
    /// </summary>
    /// <param name="client">The connected <see cref="ReliableClient"/>.</param>
    /// <param name="clientKeyPair">The X25519 keypair previously generated by
    /// <see cref="InitiateHandshakeAsync(ReliableClient, System.UInt16, System.Threading.CancellationToken)"/>.</param>
    /// <param name="packet">The packet received from the server (must be a <see cref="Handshake"/> with a 32-byte public key).</param>
    /// <returns>
    /// <c>true</c> if a 32-byte encryption key was derived and installed successfully; otherwise <c>false</c>
    /// (e.g., the packet is not a valid <see cref="Handshake"/>).
    /// </returns>
    /// <exception cref="System.ArgumentNullException">
    /// Thrown when <paramref name="client"/> is <c>null</c> or <paramref name="clientKeyPair"/> has no private key.
    /// </exception>
    /// <remarks>
    /// The shared secret is derived via <see cref="X25519.Agreement(System.Byte[], System.Byte[])"/> and
    /// hashed with <see cref="SHA3256.HashData(System.ReadOnlySpan{System.Byte})"/>.
    /// Sensitive material (private key and derived secret) is cleared from memory once the operation completes.
    /// </remarks>
    /// <example>
    /// <code>
    /// var keyPair = await client.InitiateHandshakeAsync(ct);
    /// var serverPacket = await client.ReceiveAsync(ct); // expect Handshake
    /// if (!client.FinishHandshake(keyPair, serverPacket))
    /// {
    ///     // handle error (unexpected packet)
    /// }
    /// </code>
    /// </example>
    public static System.Boolean FinishHandshake(
        this ReliableClient client,
        X25519.X25519KeyPair clientKeyPair,
        IPacket packet)
    {
        System.ArgumentNullException.ThrowIfNull(client);

        if (clientKeyPair.PrivateKey is null)
        {
            throw new System.ArgumentNullException(nameof(clientKeyPair), "X25519 private key is required.");
        }

        if (packet is not Handshake hs || hs.Data is not { Length: 32 })
        {
            return false;
        }

        System.Byte[] secret = null;

        try
        {
            // Derive X25519 shared secret (clientPriv, serverPub)
            secret = X25519.Agreement(clientKeyPair.PrivateKey, hs.Data);

            // Derive 32-byte session key using SHA-256(secret)
            client.Options.EncryptionKey = SHA3256.HashData(secret);

            InstanceManager.Instance.GetExistingInstance<ILogger>()?
                                    .Info("Handshake completed. EncryptionKey installed.");
            return true;
        }
        finally
        {
            // Best-effort scrub of sensitive material
            if (clientKeyPair.PrivateKey is not null)
            {
                System.Array.Clear(clientKeyPair.PrivateKey, 0, clientKeyPair.PrivateKey.Length);
            }

            if (secret is not null)
            {
                System.Array.Clear(secret, 0, secret.Length);
            }
        }
    }
}
